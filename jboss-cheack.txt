Tamam Hakan ğŸ‘
AÅŸaÄŸÄ±daki metni mail olarak doÄŸrudan gÃ¶nderebilirsin.
Her maddede â€œÅŸu komutla bakÄ±labilirâ€ ÅŸeklinde yazdÄ±m; sen Ã§Ä±ktÄ±larÄ± ekleyebilirsin.

â¸»

Konu: GBSTPPAYMENTSYSAPPLY â€“ Session birikimi ve GC davranÄ±ÅŸÄ± deÄŸerlendirmesi

Merhaba,

Mahmutâ€™un paylaÅŸtÄ±ÄŸÄ± bulgular Ã¼zerinden yaptÄ±ÄŸÄ±mÄ±z kontroller ve teknik deÄŸerlendirme aÅŸaÄŸÄ±dadÄ±r.

â¸»

1) InMemorySessionManager / ConcurrentHashMap heap kullanÄ±mÄ±

Undertow, aktif sessionâ€™larÄ± InMemorySessionManager iÃ§inde ConcurrentHashMap ile tutar. GC yalnÄ±zca referansÄ± kalmayan nesneleri temizler; session mapâ€™te referanslÄ± kaldÄ±klarÄ± sÃ¼rece silinmezler.

Sunucu Ã¼zerinde aÅŸaÄŸÄ±daki komut ile runtime doÄŸrulamasÄ± yapÄ±labilir:

jcmd <PID> GC.class_histogram | egrep -i "InMemorySessionManager\$SessionImpl|ConcurrentHashMap\$Node" | head -n 30

Ã‡Ä±ktÄ±da bu sÄ±nÄ±flarÄ±n yÃ¼ksek instance sayÄ±sÄ± gÃ¶rÃ¼lmesi, session nesnelerinin heapâ€™te tutulduÄŸunu ve GC tarafÄ±ndan temizlenemediÄŸini gÃ¶sterir.

â¸»

2) GCâ€™nin temizlememesi davranÄ±ÅŸÄ±

Bu durum GC problemi deÄŸildir. Session nesneleri hÃ¢lÃ¢ referanslÄ± olduÄŸu iÃ§in GC tarafÄ±ndan silinmez. Timeout dolmadÄ±kÃ§a veya referans bÄ±rakÄ±lmadÄ±kÃ§a Old Genâ€™e taÅŸÄ±nmalarÄ± normal davranÄ±ÅŸtÄ±r.

Session timeout tanÄ±mÄ±nÄ± doÄŸrulamak iÃ§in:

grep -Rni "session-timeout" WEB-INF/web.xml


â¸»

3) Restart sonrasÄ± dÃ¼zelip tekrar artÄ±ÅŸ gÃ¶rÃ¼lmesi

Restart sonrasÄ± heap ve session map sÄ±fÄ±rlanÄ±r. KÃ¶k neden devam ediyorsa (yeni session Ã¼retimi veya expire olmamasÄ±) aynÄ± bÃ¼yÃ¼me paterni yeniden oluÅŸur. Bu durum klasik memory leakâ€™ten ziyade session birikimini iÅŸaret eder.

â¸»

4) Ankara ortamÄ±nda da artÄ±ÅŸ gÃ¶rÃ¼lmesi

AynÄ± davranÄ±ÅŸÄ±n diÄŸer nodeâ€™da da gÃ¶zlenmesi, sorunun tek sunucuya Ã¶zgÃ¼ olmadÄ±ÄŸÄ±nÄ± gÃ¶sterir.

Her nodeâ€™da aÅŸaÄŸÄ±daki komut ile karÅŸÄ±laÅŸtÄ±rma yapÄ±labilir:

jcmd <PID> GC.class_histogram | grep SessionImpl


â¸»

5) Sticky session davranÄ±ÅŸÄ±

Apache konfigÃ¼rasyonunda sticky session yÃ¶nlendirmesi tanÄ±mlÄ±dÄ±r:

stickysession=JSESSIONID|jsessionid

Bu ayarÄ±n etkin Ã§alÄ±ÅŸabilmesi iÃ§in backend node route tanÄ±mlarÄ±nÄ±n da mevcut olmasÄ± gerekir. AÅŸaÄŸÄ±daki komutlarla doÄŸrulanabilir:

Apache balancer Ã¼yeleri:

grep -Rni "BalancerMember" /usr/apache/conf.d/GBSTPPAYMENTSYSAPPLY.conf

JBoss node route bilgisi:

grep -Rni "jvm-route\|instance-id" $EAP_HOME/domain/configuration/domain.xml

Route eÅŸleÅŸmesi yoksa aynÄ± kullanÄ±cÄ± farklÄ± nodeâ€™lara yÃ¶nlenerek birden fazla session oluÅŸabilir.

â¸»

6) Session timeout uygulanmasÄ±na raÄŸmen silinmiyor gÃ¶rÃ¼nmesi

Timeout dolmasÄ±na raÄŸmen sessionâ€™larÄ±n aktif kalmasÄ± aÅŸaÄŸÄ±daki durumlarda mÃ¼mkÃ¼ndÃ¼r:
	â€¢	sessionâ€™a periyodik eriÅŸim (refresh, health check vb.),
	â€¢	sticky yÃ¶nlendirme Ã§alÄ±ÅŸmÄ±yorsa farklÄ± nodeâ€™larda yeni session oluÅŸmasÄ±,
	â€¢	istemcinin sessionâ€™Ä± sÃ¼rekli yeniden kullanmasÄ±.

â¸»

7) JBoss 7 â†’ JBoss 8 sonrasÄ± gÃ¶rÃ¼nÃ¼r hale gelmesi

JBoss 8 ile Undertow ve cookie/policy davranÄ±ÅŸlarÄ± daha katÄ± hale gelmiÅŸtir. Cookie sÃ¼rekliliÄŸi veya routing davranÄ±ÅŸÄ±nda deÄŸiÅŸiklik olmasÄ± durumunda her istekte yeni session Ã¼retimi tetiklenebilir. Bu nedenle gÃ¶zlenen durum JBoss 8â€™in session silmemesinden ziyade session sÃ¼rekliliÄŸinin bozulmasÄ± ile iliÅŸkilidir.

â¸»

Ã–zetle mevcut bulgular, GC kaynaklÄ± bir bellek sÄ±zÄ±ntÄ±sÄ±ndan ziyade session nesnelerinin expire olmadan birikmesine iÅŸaret etmektedir. Cookie sÃ¼rekliliÄŸi, sticky yÃ¶nlendirme ve uygulama tarafÄ±nda gereksiz session Ã¼retimi noktalarÄ±nÄ±n doÄŸrulanmasÄ± Ã¶nerilir.

TeÅŸekkÃ¼rler.