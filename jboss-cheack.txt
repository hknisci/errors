AÅŸaÄŸÄ±da Red Hatâ€™e aÃ§acaÄŸÄ±nÄ±z vaka iÃ§in tek parÃ§a, eksiksiz ve gÃ¶nderime hazÄ±r metni hem TÃ¼rkÃ§e hem Ä°ngilizce olarak veriyorum.
Metin; session birikimi, GC/Old Gen davranÄ±ÅŸÄ±, timeout seviyesi, Ã¶lÃ§Ã¼m ihtiyacÄ± ve web server akÄ±ÅŸÄ± gibi kritik noktalarÄ± net biÃ§imde kapsar.

â¸»

ğŸ‡¹ğŸ‡· RED HAT CASE METNÄ° (TÃœRKÃ‡E)

BaÅŸlÄ±k

EAP 8 â€“ Undertow InMemorySessionManager / ConcurrentHashMap heapâ€™in ~%96â€™sÄ±nÄ± tutuyor, objeler G1 Old Genâ€™e taÅŸÄ±nÄ±yor ve Long GC oluÅŸuyor; EAP7â†’EAP8 sonrasÄ± gÃ¶rÃ¼nÃ¼r hale geldi

â¸»

Ortam Bilgisi
	â€¢	Red Hat JBoss EAP: 8.x (Domain mode)
	â€¢	Java: OpenJDK 21.0.5
	â€¢	Uygulama: GBSTPPAYMENTSYSAPPLY (EAR/WAR)
	â€¢	Web Server: Apache (reverse proxy)
	â€¢	Trafik: Apache Ã¼zerinden uygulamaya yÃ¶nlenmektedir.

â¸»

1) Problem TanÄ±mÄ±

JBoss EAP 7â€™den EAP 8â€™e yÃ¼kseltme sonrasÄ±nda uygulamada zamanla artan bellek kullanÄ±mÄ± ve Long GC alarmlarÄ± gÃ¶zlemliyoruz.

Ä°lk aÅŸamada heap artÄ±rÄ±mÄ± yapÄ±ldÄ± (Ã¶r. 4GB â†’ 8GB), ancak sorun belirli bir sÃ¼re sonra tekrar etmektedir.

KalÄ±cÄ± Ã§Ã¶zÃ¼m iÃ§in Undertow session yÃ¶netimi ve session lifecycle/expiration davranÄ±ÅŸÄ±nÄ±n doÄŸrulanmasÄ±na ihtiyaÃ§ duyulmaktadÄ±r.

â¸»

2) Bulgular (Heap dump ve runtime doÄŸrulama)

Issue anÄ±nda alÄ±nan heap dump analizine gÃ¶re:
	â€¢	io.undertow.server.session.InMemorySessionManager tek baÅŸÄ±na heapâ€™in bÃ¼yÃ¼k kÄ±smÄ±nÄ± tutmaktadÄ±r.
	â€¢	Bellek birikimi java.util.concurrent.ConcurrentHashMap$Node[] Ã¼zerinde gerÃ§ekleÅŸmektedir.
	â€¢	Retained heap oranÄ± yaklaÅŸÄ±k %96 seviyesine ulaÅŸabilmektedir.

Runtime doÄŸrulama iÃ§in alÄ±nan histogram Ã§Ä±ktÄ±larÄ±nda da ConcurrentHashMap yapÄ±larÄ±nÄ±n yÃ¼ksek sayÄ±ya ulaÅŸtÄ±ÄŸÄ± gÃ¶rÃ¼lmÃ¼ÅŸtÃ¼r:

jcmd <PID> GC.class_histogram | egrep -i "InMemorySessionManager\\$SessionImpl|ConcurrentHashMap" | head -n 30

Bu durum session objelerinin uzun Ã¶mÃ¼rlÃ¼ hale gelerek G1 Old Generationâ€™a taÅŸÄ±ndÄ±ÄŸÄ±nÄ± ve GC baskÄ±sÄ± oluÅŸturduÄŸunu dÃ¼ÅŸÃ¼ndÃ¼rmektedir.

â¸»

3) Session Timeout KonfigÃ¼rasyonu

Uygulama WAR iÃ§indeki web.xml dosyasÄ±nda session-timeout tanÄ±mÄ± bulunmamaktadÄ±r.

Bu durumda container default timeout deÄŸeri geÃ§erli olmaktadÄ±r.

Ancak timeout tanÄ±mÄ± uygulama paketinde olmasa da:
	â€¢	Undertow / servlet container seviyesinde,
	â€¢	domain.xml veya baÅŸka bir override mekanizmasÄ±yla

timeout deÄŸeri belirlenmiÅŸ olabilir.

Efektif timeout deÄŸerinin hangi seviyeden geldiÄŸinin netleÅŸtirilmesi Ã¶nemlidir.

â¸»

4) Ã–lÃ§Ã¼m Ä°htiyacÄ± ve DavranÄ±ÅŸ Analizi

KalÄ±cÄ± teÅŸhis iÃ§in aÅŸaÄŸÄ±daki davranÄ±ÅŸlarÄ±n netleÅŸtirilmesi gerekmektedir:
	1.	Session creation rate
(dakika/saat bazÄ±nda kaÃ§ yeni session oluÅŸtuÄŸu)
	2.	Timeout sÃ¼resi dolduktan sonra beklenen
session sayÄ±sÄ± ve heap dÃ¼ÅŸÃ¼ÅŸÃ¼nÃ¼n gerÃ§ekleÅŸip gerÃ§ekleÅŸmediÄŸi

Default timeout genellikle 30 dakika olduÄŸundan, timeout penceresi iÃ§inde session birikimi normal kabul edilebilir.

Ancak bizim senaryomuzda:
	â€¢	heap bÃ¼yÃ¼mesi devam etmekte,
	â€¢	Old Gen baskÄ±sÄ± artmakta,
	â€¢	GC sÃ¼releri uzamaktadÄ±r.

Bu nedenle timeout sonrasÄ± temizleme davranÄ±ÅŸÄ±nÄ±n doÄŸrulanmasÄ± kritik Ã¶nem taÅŸÄ±maktadÄ±r.

â¸»

5) Web Server / Proxy KatmanÄ± Etkisi

Apache reverse proxy yapÄ±landÄ±rmasÄ±nÄ±n session sÃ¼rekliliÄŸini etkileyip etkilemediÄŸinin doÄŸrulanmasÄ± gerekmektedir.

Ã–zellikle aÅŸaÄŸÄ±daki cookie/header davranÄ±ÅŸlarÄ±nÄ±n kontrol edilmesi Ã¶nemlidir:
	â€¢	Set-Cookie headerâ€™larÄ±nÄ±n korunmasÄ±
	â€¢	Secure / SameSite attribute davranÄ±ÅŸÄ±
	â€¢	Cookie domain & path rewrite kurallarÄ±
	â€¢	Proxy header manipÃ¼lasyonu

Bu kontroller sonucuna gÃ¶re aksiyonlarÄ±n:
	â€¢	platform/proxy tarafÄ±nda
	â€¢	veya uygulama tarafÄ±nda (session kullanÄ±m paterni)

planlanmasÄ± gerekecektir.

â¸»

6) Hipotezimiz

GCâ€™nin objeleri temizleyememesi bir GC hatasÄ± olmayÄ±p, objelerin hÃ¢lÃ¢ strong reference ile tutulmasÄ± nedeniyle olabilir.

AÅŸaÄŸÄ±daki iki senaryonun doÄŸrulanmasÄ±nÄ± istiyoruz:
	1.	YÃ¼ksek session creation rate nedeniyle timeout penceresi iÃ§inde doÄŸal bir birikim oluÅŸmasÄ±
	2.	Session expire olduktan sonra:
	â€¢	Undertow cleanup mekanizmasÄ±nÄ±n gecikmesi
	â€¢	veya framework/cache/session attribute referanslarÄ±nÄ±n objeleri tutmaya devam etmesi

â¸»

7) Red Hatâ€™ten Teknik YÃ¶nlendirme Talebimiz

Undertow session lifecycle & cleanup
	1.	Session timeout dolduktan sonra expired sessionâ€™lar hangi mekanizma ile temizlenir?
	2.	Cleanup iÅŸlemi yÃ¼k altÄ±nda gecikebilir mi? NasÄ±l doÄŸrulanÄ±r?
	3.	Session invalidation sonrasÄ± objeler hemen GCâ€™ye uygun hale gelir mi?

G1GC & Old Gen davranÄ±ÅŸÄ±
	4.	Session objelerinin Old Genâ€™e taÅŸÄ±nmasÄ±na sebep olabilecek tipik durumlar nelerdir?
	5.	GC Ã§alÄ±ÅŸmasÄ±na raÄŸmen heap dÃ¼ÅŸmÃ¼yorsa hangi metriklere bakÄ±lmalÄ±dÄ±r?
	6.	High-session workload ortamlarÄ± iÃ§in Ã¶nerilen GC tuning var mÄ±?

Heap dump referans zinciri
	7.	InMemorySessionManager iÃ§indeki map yapÄ±sÄ±nda tipik referans zinciri nasÄ±ldÄ±r?
	8.	Dominator tree analizinde hangi pathâ€™lere odaklanmalÄ±yÄ±z?
	9.	Bu pattern beklenen davranÄ±ÅŸ mÄ± yoksa bilinen bir issueâ€™a benziyor mu?

EAP7 â†’ EAP8 farklarÄ±
	10.	EAP8â€™de session handling/cleanup davranÄ±ÅŸÄ±nda deÄŸiÅŸiklik var mÄ±?
	11.	Bu alanda Ã¶nerilen minimum CP/patch seviyesi var mÄ±?

â¸»

8) SaÄŸlayabileceÄŸimiz Veriler

Ä°htiyaÃ§ halinde aÅŸaÄŸÄ±daki verileri paylaÅŸabiliriz:
	â€¢	Issue anÄ±nda alÄ±nmÄ±ÅŸ heap dump
	â€¢	GC histogram Ã¶rnekleri
	â€¢	GC loglarÄ± ve heap kullanÄ±m trendleri
	â€¢	domain.xml / host.xml ilgili bÃ¶lÃ¼mleri
	â€¢	Apache proxy konfigÃ¼rasyonu

â¸»

TeÅŸekkÃ¼rler.

â¸»

ğŸ‡¬ğŸ‡§ RED HAT CASE TEXT (ENGLISH)

Title

EAP 8 â€“ Undertow InMemorySessionManager / ConcurrentHashMap retains ~96% of heap, objects promoted to G1 Old Gen causing long GC times; became visible after EAP7â†’EAP8 upgrade

â¸»

Environment
	â€¢	Red Hat JBoss EAP: 8.x (Domain mode)
	â€¢	Java: OpenJDK 21.0.5
	â€¢	Application: GBSTPPAYMENTSYSAPPLY (EAR/WAR)
	â€¢	Front-end: Apache reverse proxy
	â€¢	Traffic is routed through Apache to the application.

â¸»

1) Problem Summary

After upgrading from JBoss EAP 7 to EAP 8, we observe steadily increasing memory usage and recurring long GC alarms.

Heap size was increased (e.g., 4GB â†’ 8GB) as a mitigation, but the issue reappears after some time.

We require validation of Undertow session lifecycle and expiration/cleanup behavior to identify a permanent solution.

â¸»

2) Evidence (Heap dump & runtime confirmation)

Heap dump captured during the issue shows:
	â€¢	A single instance of io.undertow.server.session.InMemorySessionManager retains a very large portion of the heap.
	â€¢	Retained memory is accumulated in java.util.concurrent.ConcurrentHashMap$Node[].
	â€¢	Retained heap can reach approximately ~96%.

Runtime histogram confirms high instance counts of ConcurrentHashMap-related structures:

jcmd <PID> GC.class_histogram | egrep -i "InMemorySessionManager\\$SessionImpl|ConcurrentHashMap" | head -n 30

This suggests session-related objects become long-lived and are promoted to G1 Old Generation, leading to GC pressure.

â¸»

3) Session Timeout Configuration

No session-timeout is defined in the application web.xml.

In this case, container default timeout is effective.

However, the effective timeout may be defined at:
	â€¢	Undertow / servlet container level
	â€¢	domain.xml or override configuration

Confirming the effective timeout source is critical.

â¸»

4) Measurement Need & Behavioral Analysis

To reach a definitive diagnosis, we need to clarify:
	1.	Session creation rate
(number of new sessions per minute/hour)
	2.	Whether we observe the expected
drop in session count and heap usage after timeout/expiration

Since the default timeout is typically 30 minutes, growth within the timeout window may be expected.

However, in our case:
	â€¢	heap growth continues,
	â€¢	Old Gen pressure increases,
	â€¢	GC times become longer.

Therefore, expiration and cleanup behavior must be verified.

â¸»

5) Web Server / Proxy Layer Impact

We want to validate whether Apache reverse proxy configuration impacts session continuity.

Particularly:
	â€¢	Set-Cookie header preservation
	â€¢	Secure / SameSite attributes
	â€¢	Cookie domain & path rewriting
	â€¢	Proxy header manipulation

Depending on findings, remediation may be required at:
	â€¢	platform/proxy level, or
	â€¢	application session usage level.

â¸»

6) Our Hypothesis

This does not appear to be a GC defect; objects may remain strongly referenced and therefore not eligible for garbage collection.

We would like to validate two scenarios:
	1.	Natural accumulation within the timeout window due to high session creation rate.
	2.	After expiration:
	â€¢	Undertow cleanup may be delayed, or
	â€¢	framework/cache/session attribute references may retain objects.

â¸»

7) Questions for Red Hat

Undertow session lifecycle & cleanup
	1.	What mechanism cleans expired sessions after timeout?
	2.	Can cleanup be delayed under load? How can this be verified?
	3.	Are session objects immediately GC-eligible after invalidation?

G1GC & Old Gen behavior
	4.	What typical conditions cause session objects to be promoted to Old Gen?
	5.	If GC runs but heap does not decrease, which metrics should be analyzed?
	6.	Are there GC tuning recommendations for high-session workloads?

Heap dump reference chains
	7.	What is the typical reference chain structure in InMemorySessionManager?
	8.	Which dominator paths should we focus on?
	9.	Does this pattern indicate expected behavior or a known issue?

EAP7 â†’ EAP8 behavioral differences
	10.	Are there changes in session handling/cleanup behavior in EAP8?
	11.	Is there a recommended minimum CP/patch level?

â¸»

8) Data Available

We can provide:
	â€¢	Heap dump captured during the issue
	â€¢	GC histogram samples
	â€¢	GC logs & heap usage trends
	â€¢	domain.xml / host.xml relevant sections
	â€¢	Apache proxy configuration

â¸»

Thank you.

â¸»

EÄŸer istersen bir sonraki adÄ±mda:

âœ… Caseâ€™e eklenecek 2â€“3 cÃ¼mlelik executive summary
âœ… Support mÃ¼hendisi hÄ±zlÄ± anlayabilsin diye ultra kÄ±sa versiyon
âœ… Case aÃ§tÄ±ktan sonra ilk yanÄ±t gelmeden Ã¶nce yapÄ±lacak Ã¶lÃ§Ã¼mler

hazÄ±rlayabilirim.