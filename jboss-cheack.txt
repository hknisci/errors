Merhaba,

Mahmut’un paylaştığı bulgular üzerinden yaptığımız kontroller ve teknik değerlendirme aşağıdadır.

⸻

1) InMemorySessionManager / ConcurrentHashMap heap kullanımı

Undertow, aktif session’ları InMemorySessionManager içinde ConcurrentHashMap ile tutar. GC yalnızca referansı kalmayan nesneleri temizler; session map’te referanslı kaldıkları sürece silinmezler.

Sunucu üzerinde aşağıdaki komut ile runtime doğrulaması yapılabilir:

[was@gbstpp07]/home/was>jcmd 4966 GC.class_histogram | egrep -i "InMemorySessionManager\SessionImpl|ConcurrentHashMap" | head -n 30
  14:        116932        3741824  java.util.concurrent.ConcurrentHashMap$Node (java.base@21.0.5)
  17:         21830        2690272  [Ljava.util.concurrent.ConcurrentHashMap$Node; (java.base@21.0.5)
  22:         31281        2001984  java.util.concurrent.ConcurrentHashMap (java.base@21.0.5)
 212:          1792         114688  net.sf.ehcache.store.chm.SelectableConcurrentHashMap$Segment
 370:          1792          43008  [Lnet.sf.ehcache.store.chm.SelectableConcurrentHashMap$HashEntry;
 516:          1396          22336  java.util.concurrent.ConcurrentHashMap$ValuesView (java.base@21.0.5)
 803:            14           7392  [Lnet.sf.ehcache.store.chm.SelectableConcurrentHashMap$Segment;
 822:            24           6720  java.util.concurrent.ConcurrentHashMap$CounterCell (java.base@21.0.5)
 909:           212           5088  java.util.concurrent.ConcurrentHashMap$KeySetView (java.base@21.0.5)
1333:            88           1408  java.util.concurrent.ConcurrentHashMap$EntrySetView (java.base@21.0.5)
1588:            14            896  net.sf.ehcache.store.chm.SelectableConcurrentHashMap
1769:            16            640  com.sun.faces.util.MultiKeyConcurrentHashMap$Segment
2158:            16            384  [Lcom.sun.faces.util.MultiKeyConcurrentHashMap$HashEntry;
2473:            12            288  [Ljava.util.concurrent.ConcurrentHashMap$CounterCell; (java.base@21.0.5)
2803:            14            224  net.sf.ehcache.store.chm.SelectableConcurrentHashMap$PinnedKeySet
5068:             1             80  [Lcom.sun.faces.util.MultiKeyConcurrentHashMap$Segment;
5788:             1             72  org.glassfish.expressly.lang.ExpressionBuilder$SoftConcurrentHashMap
5827:             1             72  org.jboss.el.cache.BeanPropertiesCache$SoftConcurrentHashMap
7645:             2             48  org.jboss.weld.contexts.beanstore.ConcurrentHashMapBeanStore
8060:             1             40  com.sun.faces.util.MultiKeyConcurrentHashMap$HashEntry
10390:             1             24  com.sun.faces.util.MultiKeyConcurrentHashMap
12794:             1             16  com.hazelcast.internal.serialization.impl.defaultserializers.ConcurrentHashMapStreamSerializer
14170:             1             16  net.sf.ehcache.store.chm.SelectableConcurrentHashMap$DummyPinnedKey
14171:             1             16  net.sf.ehcache.store.chm.SelectableConcurrentHashMap$DummyPinnedValue
[was@gbstpp07]/home/was>

Çıktıda bu sınıfların yüksek instance sayısı görülmesi, session nesnelerinin heap’te tutulduğunu ve GC tarafından temizlenemediğini gösterir.

⸻

2) GC’nin temizlememesi davranışı

Bu durum GC problemi değildir. Session nesneleri hâlâ referanslı olduğu için GC tarafından silinmez. Timeout dolmadıkça veya referans bırakılmadıkça Old Gen’e taşınmaları normal davranıştır.

Session timeout tanımını doğrulamak için:

[was@gbstpp07]/home/was>cat /vhosting8/GBSTPPAYMENTSYSAPPLY.ear/GARANTI_PAYMENTSYSAPPLY_WEB.war/WEB-INF/web.xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xmlns="https://jakarta.ee/xml/ns/jakartaee" xmlns:web="https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd" 
  xsi:schemaLocation="https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd" id="WebApp_ID" version="5.0" metadata-complete="true">
        <absolute-ordering />
        <display-name>com.garanti.paymentsysapply.web</display-name>
        <listener>
                <listener-class>com.garanti.common.web.listener.ContextLoaderListener</listener-class>
        </listener>
</web-app>
[was@gbstpp07]/home/was>grep -Rni "session-timeout" /vhosting8/GBSTPPAYMENTSYSAPPLY.ear/GARANTI_PAYMENTSYSAPPLY_WEB.war/WEB-INF/web.xml
[was@gbstpp07]/home/was>


⸻

3) Restart sonrası düzelip tekrar artış görülmesi

Restart sonrası heap ve session map sıfırlanır. Kök neden devam ediyorsa (yeni session üretimi veya expire olmaması) aynı büyüme paterni yeniden oluşur. Bu durum klasik memory leak’ten ziyade session birikimini işaret eder.

⸻

4) Ankara ortamında da artış görülmesi

Aynı davranışın diğer node’da da gözlenmesi, sorunun tek sunucuya özgü olmadığını gösterir.

⸻

5) JBoss 7 → JBoss 8 sonrası görünür hale gelmesi

JBoss 8 ile Undertow ve cookie/policy davranışları daha katı hale gelmiştir. Cookie sürekliliği veya routing davranışında değişiklik olması durumunda her istekte yeni session üretimi tetiklenebilir. Bu nedenle gözlenen durum JBoss 8’in session silmemesinden ziyade session sürekliliğinin bozulması ile ilişkilidir.

⸻

Özetle mevcut bulgular, GC kaynaklı bir bellek sızıntısından ziyade session nesnelerinin expire olmadan birikmesine işaret etmektedir. Cookie sürekliliği, sticky yönlendirme ve uygulama tarafında gereksiz session üretimi noktalarının doğrulanması önerilir.

Teşekkürler
BUNA GÖRE MAİLİ TEKRAR YAZ
