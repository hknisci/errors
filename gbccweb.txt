Tamam â€” 700 CLOSE-WAIT artÄ±k â€œanlÄ±k 2 taneâ€ deÄŸil, gerÃ§ek bir problem. CLOSE-WAITâ€™in anlamÄ± deÄŸiÅŸmiyor:

KarÅŸÄ± taraf baÄŸlantÄ±yÄ± kapatmÄ±ÅŸ, ama senin uygulama (Java/JBoss) o socketâ€™i kapatmamÄ±ÅŸ.
Bu genelde HTTP client tarafÄ±nda response/stream kapatÄ±lmÄ±yor demektir (connection leak).

Bu durum bÃ¼yÃ¼dÃ¼kÃ§e:
	â€¢	JBossâ€™ta threadâ€™ler I/O bekler, poolâ€™lar dolar
	â€¢	FD ve native memory artar
	â€¢	JBoss yavaÅŸlar
	â€¢	IHS backend cevap bekler â†’ busy thread artar, IHS restartâ€™ta childâ€™lar Ã§Ä±kamaz (AH00046)

AÅŸaÄŸÄ±daki adÄ±mlar â€œhangi uygulama / hangi remote / hangi kod yoluâ€ ve â€œhemen ne yapmalÄ±â€yÄ± netleÅŸtirir.

â¸»

1) 700 CLOSE-WAIT hangi PIDâ€™de? (kritik)

Ã–nce doÄŸru JVM PIDâ€™yi bul:

jcmd -l

Sonra her Java PID iÃ§in CLOSE-WAIT say:

for p in $(pgrep -f java); do
  c=$(ss -antp 2>/dev/null | grep "pid=$p" | grep -c CLOSE-WAIT || true)
  if [ "$c" -gt 0 ]; then
    echo "$p CLOSE-WAIT=$c"
  fi
done | sort -k2 -nr

ğŸ‘‰ 700 olan PIDâ€™yi bulunca onunla devam edeceÄŸiz.

â¸»

2) 700 CLOSE-WAIT hangi remote IP/portâ€™a gidiyor?

(En yÃ¼k taÅŸÄ±yan kanÄ±t)

PID=<700_olan_pid>

ss -antp | grep "pid=$PID" | grep CLOSE-WAIT | awk '{print $5}' \
 | sed 's/::ffff://g' | sort | uniq -c | sort -nr | head -30

Burada genelde tek bir IP/port Ã§ok baskÄ±n Ã§Ä±kar. O servis/endpoint â€œproblem kaynaÄŸÄ±â€ olur.

â¸»

3) CLOSE-WAIT socketâ€™leri hangi process FDâ€™lerine baÄŸlÄ±?

Bu da leakâ€™in OS kanÄ±tÄ±:

lsof -p $PID -nP | grep TCP | grep CLOSE_WAIT | head -20
lsof -p $PID -nP | grep TCP | grep CLOSE_WAIT | wc -l


â¸»

4) AynÄ± anda thread dump alÄ±p â€œhangi kod yoluâ€ olduÄŸunu yakala

Leakâ€™i asÄ±l dÃ¼zeltecek yer burasÄ±.

jcmd $PID Thread.print > /tmp/th_$PID.txt
grep -n "HttpURLConnection\|com.sun.jersey\|org.glassfish.jersey\|socketRead0\|parseHTTPHeader" -n /tmp/th_$PID.txt | head -80

Ve kaÃ§ thread socketRead0â€™da?

grep -c "SocketInputStream.socketRead0" /tmp/th_$PID.txt


â¸»

5) Bu sorunun tipik uygulama sebepleri

Senin Ã¶nceki dumpâ€™ta zaten ÅŸu var:
	â€¢	HttpsURLConnectionImpl.getResponseCode
	â€¢	com.sun.jersey.client...
	â€¢	digitalonboardingio.swagger.client...

Bu stack ÅŸunu dÃ¼ÅŸÃ¼ndÃ¼rÃ¼r:

A) Jersey Client / HttpURLConnection response kapatÄ±lmÄ±yor

Ã–rn. (Jersey 1/2 fark etmez) mutlaka:
	â€¢	response.close() / ClientResponse.close()
	â€¢	entity stream close()

B) Timeout yok / Ã§ok yÃ¼ksek

Timeout olmazsa request threadâ€™i uzun sÃ¼re takÄ±lÄ±r, retry/reconnect ile connection sayÄ±sÄ± ÅŸiÅŸer.

â¸»

6) Hemen etkili mitigasyonlar

âœ… En hÄ±zlÄ± toparlama (kÃ¶k neden Ã§Ã¶zÃ¼lene kadar)
	â€¢	Problemli Ã§aÄŸrÄ±larÄ±n concurrencyâ€™sini dÃ¼ÅŸÃ¼r (bulkhead): thread pool/queue limit
	â€¢	Timeout ekle (connect + read)
	â€¢	DÄ±ÅŸ servise circuit breaker: hata alÄ±nca bir sÃ¼re denemeyi kes
	â€¢	JBoss restart kÄ±sa vadede CLOSE-WAITâ€™i temizler ama root cause kalÄ±r.

âœ… IHS tarafÄ± iÃ§in de koruma

JBoss yavaÅŸladÄ±ÄŸÄ±nda IHS threadâ€™leri birikmesin diye:
	â€¢	Proxy timeoutâ€™larÄ± mantÄ±klÄ± seviyeye Ã§ek
	â€¢	KeepAliveTimeoutâ€™u dÃ¼ÅŸÃ¼r
	â€¢	Backend connection pool / max conn ayarla (kullandÄ±ÄŸÄ±nÄ±z mod_proxy/mod_jk/mod_clusterâ€™a gÃ¶re)

â¸»

Bana ÅŸu 2 Ã§Ä±ktÄ±yÄ± ver, direkt â€œhangi servis/kodâ€ diyeceÄŸim
	1.	700 CLOSE-WAIT olan PID
	2.	Bu komutun Ã§Ä±ktÄ±sÄ±:

ss -antp | grep "pid=$PID" | grep CLOSE-WAIT | awk '{print $5}' | sort | uniq -c | sort -nr | head -30

Ã‡Ä±ktÄ±da hangi IP:port baskÄ±nsa, o servise giden client kodunda response close / stream close / timeout dÃ¼zeltmesi yapacaÄŸÄ±z.