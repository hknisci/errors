Aynen — çıktıların net: container adı dc ve pod’da digital-accounts-composition-v0. Demek ki YAML-parse fonksiyonu “ENV” yakalayıp -c ENV ile oc exec çalıştırmış. Bunu tamamen bitirecek şekilde scripti baştan full veriyorum:
	•	✅ Container adını yaml parse etmiyor, doğrudan oc get dc ... jsonpath ile alıyor.
	•	✅ oc exec patlarsa log’a pod container listesi basıyor (senin istediğin mini güvenlik).
	•	✅ POD_WAIT_INTERVAL kadar artıyor (sabit +5 değil).
	•	✅ JAVA_OPTIONS varsa:
	•	JAVA_OPTS_APPEND yoksa → rename
	•	ikisi birlikte varsa → JAVA_OPTIONS item’ını komple kaldır
	•	✅ Post-check’te rollout sonrası READY pod bekleyip tekrar java -version + jcmd okuyor.

Aşağıdaki scripti direkt komple replace et.

#!/usr/bin/env bash
set -u
IFS=$'\n\t'

MODE="${1:-}"
shift || true

NS_FILTER=""
DC_FILTER=""
DRY_RUN="0"
LIMIT_DCS="0"
INCLUDE_NS_REGEX=""
EXCLUDE_NS_REGEX=""
POST_CHECK="1"
ROLLOUT_TIMEOUT="180s"
POD_WAIT_TIMEOUT="120s"
POD_WAIT_INTERVAL="5s"

usage() {
  cat <<'EOF'
Usage:
  oc_dc_java_audit.sh {list|apply} [options]

Options:
  --namespace, -n <ns>          Only this namespace (REQUIRED for apply)
  --dc <dc-name>               Only this DeploymentConfig name (within namespace)
  --dry-run                    Apply mode: do not oc apply / rollout; just report would-change
  --limit <N>                  Process at most N DCs per run
  --include-ns-regex <regex>   Only namespaces matching regex
  --exclude-ns-regex <regex>   Skip namespaces matching regex
  --no-post-check              Apply mode: skip post-rollout java/jcmd checks
  --rollout-timeout <dur>      Rollout status wait time (default 180s), e.g. 120s
  --pod-wait-timeout <dur>     Post-rollout pod wait timeout (default 120s), e.g. 2m/120s
  --pod-wait-interval <dur>    Post-rollout poll interval (default 5s), e.g. 10s

Examples:
  ./oc_dc_java_audit.sh list
  ./oc_dc_java_audit.sh list -n fin-accnt-mngmt-lab
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dry-run --dc product-channel-v0
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dc product-channel-v0
EOF
}

if [[ "$MODE" != "list" && "$MODE" != "apply" ]]; then
  usage
  exit 2
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --namespace|-n) NS_FILTER="${2:-}"; shift 2;;
    --dc) DC_FILTER="${2:-}"; shift 2;;
    --dry-run) DRY_RUN="1"; shift;;
    --limit) LIMIT_DCS="${2:-0}"; shift 2;;
    --include-ns-regex) INCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --exclude-ns-regex) EXCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --no-post-check) POST_CHECK="0"; shift;;
    --rollout-timeout) ROLLOUT_TIMEOUT="${2:-180s}"; shift 2;;
    --pod-wait-timeout) POD_WAIT_TIMEOUT="${2:-120s}"; shift 2;;
    --pod-wait-interval) POD_WAIT_INTERVAL="${2:-5s}"; shift 2;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown argument: $1"; usage; exit 2;;
  esac
done

if [[ "$MODE" == "apply" && -z "$NS_FILTER" ]]; then
  echo "ERROR: apply mode requires --namespace <ns> for safety."
  exit 5
fi

TS="$(date +%Y%m%d_%H%M%S)"
LOG_FILE="./oc_dc_java_audit_${MODE}_${TS}.log"

log() {
  local lvl="$1"; shift
  printf "%s [%s] %s\n" "$(date -Is)" "$lvl" "$*" | tee -a "$LOG_FILE" >/dev/null
}

# run_cmd <ns> <dc> <quiet_stderr:0|1> -- <command...>
run_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  local quiet="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (quiet_stderr=${quiet})"

  local out rc
  if [[ "$quiet" == "1" ]]; then
    out="$("${cmd[@]}" 2>/dev/null)" || rc=$?
  else
    out="$("${cmd[@]}" 2>&1)" || rc=$?
  fi
  rc="${rc:-0}"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} :: ${out}"
    printf "%s" "$out"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} :: $(echo "$out" | head -n 1 | tr -d '\r')"
  printf "%s" "$out"
  return 0
}

# run_apply_cmd: stdout to caller, stderr only to log
run_apply_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_apply_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (stdout only to caller; stderr -> log)"

  local stdout tmp_err rc
  tmp_err="$(mktemp)"
  stdout="$("${cmd[@]}" 2>"$tmp_err")" || rc=$?
  rc="${rc:-0}"

  if [[ -s "$tmp_err" ]]; then
    log "WARN" "ns=${ns} dc=${dc} stderr :: $(head -n 3 "$tmp_err" | tr -d '\r')"
    while read -r line; do
      [[ -n "$line" ]] && log "STDERR" "ns=${ns} dc=${dc} :: $line"
    done < "$tmp_err"
  fi
  rm -f "$tmp_err"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} stdout :: ${stdout}"
    printf "%s" "$stdout"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} stdout :: $(echo "$stdout" | head -n 1 | tr -d '\r')"
  printf "%s" "$stdout"
  return 0
}

require_oc_login() {
  command -v oc >/dev/null 2>&1 || { echo "ERROR: oc not found in PATH" >&2; exit 10; }
  local out rc
  out="$(oc whoami 2>&1)" || rc=$?
  rc="${rc:-0}"
  if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: oc is not logged in. oc whoami failed: $out" >&2
    exit 3
  fi
}

sanitize_one_line() { tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/ $//'; }

_duration_to_seconds() {
  local d="$1"
  if [[ "$d" =~ ^[0-9]+s$ ]]; then
    echo "${d%s}"
  elif [[ "$d" =~ ^[0-9]+m$ ]]; then
    echo "$(( ${d%m} * 60 ))"
  else
    # default fallback
    echo "5"
  fi
}

# Extract selector from DC YAML spec.selector -> key=value,key2=value2
dc_selector_from_yaml() {
  awk '
    BEGIN{spec=0; inSel=0}
    /^spec:/ {spec=1}
    spec && /^[[:space:]]+selector:/ {inSel=1; next}
    inSel {
      if ($0 ~ /^[[:space:]]{4}[A-Za-z0-9_.-]+:[[:space:]]*[A-Za-z0-9_.-]+[[:space:]]*$/) {
        gsub(/^[[:space:]]+/, "", $0)
        split($0,a,":")
        k=a[1]; v=a[2]
        gsub(/[[:space:]]+/, "", v)
        if (k != "" && v != "") {
          if (out != "") out=out ","
          out=out k "=" v
        }
        next
      }
      if ($0 !~ /^[[:space:]]{4}/) {inSel=0}
    }
    END{print out}
  '
}

# Container name (DO NOT parse YAML; read from API)
get_dc_first_container_name() {
  local ns="$1"
  local dc="$2"
  local name
  name="$(run_cmd "$ns" "$dc" 1 -- oc get dc -n "$ns" "$dc" -o jsonpath='{.spec.template.spec.containers[0].name}' || true)"
  name="$(echo "$name" | tr -d '\r' | tr -d '\n')"
  echo "$name"
}

# mini güvenlik: pod container listesi (exec hatasında log için)
log_pod_container_list() {
  local ns="$1"
  local dc="$2"
  local pod="$3"
  local names
  names="$(run_cmd "$ns" "$dc" 0 -- oc get pod -n "$ns" "$pod" -o jsonpath='{.spec.containers[*].name}{"\n"}' || true)"
  log "INFO" "ns=${ns} dc=${dc} pod=${pod} containers :: $(echo "$names" | sanitize_one_line)"
}

find_one_pod_for_dc() {
  local ns="$1"
  local dc="$2"
  local dc_yaml="$3"

  local pods
  pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "deploymentconfig=$dc" \
    --field-selector=status.phase=Running \
    -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  if [[ -n "$pods" ]]; then
    echo "$pods" | head -n 1
    return 0
  fi

  local sel
  sel="$(printf "%s" "$dc_yaml" | dc_selector_from_yaml | tr -d '\r')"
  if [[ -n "$sel" ]]; then
    pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "$sel" \
      --field-selector=status.phase=Running \
      -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
    if [[ -n "$pods" ]]; then
      echo "$pods" | head -n 1
      return 0
    fi
  fi

  echo ""
  return 0
}

wait_for_ready_pod() {
  local ns="$1"
  local dc="$2"
  local dc_yaml="$3"
  local timeout_s interval_s elapsed

  timeout_s="$(_duration_to_seconds "$POD_WAIT_TIMEOUT")"
  interval_s="$(_duration_to_seconds "$POD_WAIT_INTERVAL")"
  [[ "$timeout_s" -le 0 ]] && timeout_s=120
  [[ "$interval_s" -le 0 ]] && interval_s=5

  elapsed=0
  while [[ "$elapsed" -le "$timeout_s" ]]; do
    local pod ready
    pod="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml" | tr -d '\r')"
    if [[ -n "$pod" ]]; then
      ready="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" "$pod" -o jsonpath='{.status.containerStatuses[0].ready}' || true)"
      if [[ "$ready" == "true" ]]; then
        echo "$pod"
        return 0
      fi
    fi
    sleep "$POD_WAIT_INTERVAL"
    elapsed=$((elapsed + interval_s))
  done

  echo ""
  return 0
}

extract_java_env_keys() {
  grep -E '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA(_[A-Z0-9_]+)?[[:space:]]*$' \
    | sed -E 's/.*name:[[:space:]]*//g' \
    | sort -u \
    | paste -sd ',' - \
    | sed -E 's/^$/-/'
}

has_java_options_env() { grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$'; }
has_java_opts_append_env() { grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTS_APPEND[[:space:]]*$'; }

rename_java_options_to_append() {
  sed -E 's/^([[:space:]]*-[[:space:]]name:[[:space:]]*)JAVA_OPTIONS([[:space:]]*)$/\1JAVA_OPTS_APPEND\2/'
}

# Remove the whole YAML item that starts with "- name: JAVA_OPTIONS" (same indent)
remove_java_options_item() {
  awk '
    BEGIN{skip=0; indent=""}
    {
      line=$0
      if (skip==0) {
        if (match(line, /^([[:space:]]*)-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$/, m)) {
          indent=m[1]
          skip=1
          next
        }
        print line
        next
      } else {
        pat="^" indent "-[[:space:]]name:[[:space:]]"
        if (line ~ pat) {
          skip=0
          print line
          next
        }
        next
      }
    }
  '
}

: > "$LOG_FILE"
log "INFO" "Started mode=${MODE} log=${LOG_FILE} ns=${NS_FILTER:-} dc=${DC_FILTER:-} dry_run=${DRY_RUN} post_check=${POST_CHECK} rollout_timeout=${ROLLOUT_TIMEOUT} pod_wait_timeout=${POD_WAIT_TIMEOUT} pod_wait_interval=${POD_WAIT_INTERVAL}"
require_oc_login
log "INFO" "oc whoami=$(oc whoami 2>/dev/null)"

printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
  "NAMESPACE" "DEPLOYMENTCONFIG" "JAVA_ENV_KEYS" "TARGET_ENV_PRESENT" "POD" "JAVA_VERSION" "JCMD_VM_FLAGS" "APPLY_RESULT"

NS_LIST_RAW="$(run_cmd "-" "-" 1 -- oc get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
if [[ -z "$NS_LIST_RAW" ]]; then
  log "ERR" "No namespaces returned."
  exit 4
fi

while read -r ns; do
  [[ -z "$ns" ]] && continue

  [[ -n "$NS_FILTER" && "$ns" != "$NS_FILTER" ]] && continue
  if [[ -n "$INCLUDE_NS_REGEX" ]] && ! echo "$ns" | grep -Eq "$INCLUDE_NS_REGEX"; then continue; fi
  if [[ -n "$EXCLUDE_NS_REGEX" ]] && echo "$ns" | grep -Eq "$EXCLUDE_NS_REGEX"; then continue; fi

  dc_list="$(run_cmd "$ns" "-" 1 -- oc get dc -n "$ns" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  [[ -z "$dc_list" ]] && continue

  dc_processed=0
  while read -r dc; do
    [[ -z "$dc" ]] && continue
    [[ -n "$DC_FILTER" && "$dc" != "$DC_FILTER" ]] && continue

    dc_processed=$((dc_processed+1))
    if [[ "$LIMIT_DCS" -gt 0 && "$dc_processed" -gt "$LIMIT_DCS" ]]; then
      log "INFO" "ns=${ns} :: reached --limit ${LIMIT_DCS}, stopping."
      break
    fi

    dc_yaml="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
    if [[ -z "$dc_yaml" ]]; then
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$ns" "$dc" "ERROR:dc_yaml_unreadable" "-" "-" "-" "-" "-"
      continue
    fi

    java_keys="$(printf "%s" "$dc_yaml" | extract_java_env_keys)"

    target_present="none"
    has_opt="0"; has_app="0"
    if printf "%s" "$dc_yaml" | has_java_options_env; then has_opt="1"; fi
    if printf "%s" "$dc_yaml" | has_java_opts_append_env; then has_app="1"; fi

    if [[ "$has_opt" == "1" && "$has_app" == "1" ]]; then
      target_present="JAVA_OPTIONS+JAVA_OPTS_APPEND"
    elif [[ "$has_opt" == "1" ]]; then
      target_present="JAVA_OPTIONS"
    elif [[ "$has_app" == "1" ]]; then
      target_present="JAVA_OPTS_APPEND"
    fi

    # container name from API (no YAML parse)
    container_name="$(get_dc_first_container_name "$ns" "$dc")"
    [[ -z "$container_name" ]] && container_name="$dc"

    # Pre-check pod
    pod_name="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml" | tr -d '\r')"
    java_ver="-"
    jcmd_flags="-"
    if [[ -n "$pod_name" ]]; then
      java_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -c "$container_name" -- java -version || true)"
      if echo "$java_out" | grep -qiE '(container .* is not valid|container not found|BadRequest)'; then
        log_pod_container_list "$ns" "$dc" "$pod_name"
      fi
      java_ver="$(echo "$java_out" | head -n 2 | sanitize_one_line)"
      [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed"

      jcmd_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -c "$container_name" -- jcmd 1 VM.flags || true)"
      if echo "$jcmd_out" | grep -qiE '(container .* is not valid|container not found|BadRequest)'; then
        log_pod_container_list "$ns" "$dc" "$pod_name"
      fi
      jcmd_flags="$(echo "$jcmd_out" | sanitize_one_line)"
      [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing"
    else
      pod_name="-"
      java_ver="WARN:no_running_pod_found"
      jcmd_flags="WARN:no_running_pod_found"
    fi

    apply_result="-"
    if [[ "$MODE" == "apply" ]]; then
      if [[ "$has_opt" == "1" ]]; then
        tmp_out="$(mktemp)"

        # TRANSFORM RULES:
        # 1) Only JAVA_OPTIONS -> rename to JAVA_OPTS_APPEND (value/valueFrom untouched)
        # 2) JAVA_OPTIONS + JAVA_OPTS_APPEND -> remove JAVA_OPTIONS item (no duplicate)
        if [[ "$has_app" == "1" ]]; then
          printf "%s" "$dc_yaml" | remove_java_options_item > "$tmp_out"
        else
          printf "%s" "$dc_yaml" | rename_java_options_to_append > "$tmp_out"
        fi

        # sanity
        if grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$' "$tmp_out"; then
          apply_result="ERROR:transform_failed_java_options_still_present"
          log "ERR" "ns=${ns} dc=${dc} :: transform failed (JAVA_OPTIONS still present)."
          rm -f "$tmp_out"
        else
          if [[ "$DRY_RUN" == "1" ]]; then
            apply_result="DRYRUN:would_apply_and_rollout"
            log "INFO" "ns=${ns} dc=${dc} :: DRY-RUN: would oc apply + rollout latest."
            rm -f "$tmp_out"
          else
            apply_out="$(run_apply_cmd "$ns" "$dc" -- oc apply -n "$ns" -f "$tmp_out" || true)"
            rm -f "$tmp_out"

            rollout_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout latest -n "$ns" "dc/${dc}" || true)"
            status_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout status -n "$ns" "dc/${dc}" --timeout="${ROLLOUT_TIMEOUT}" || true)"

            if echo "$status_out" | grep -qiE '(successfully rolled out|rolled out)'; then
              apply_result="APPLIED+ROLLEDOUT"
            else
              apply_result="APPLIED_BUT_ROLLOUT_PENDING"
            fi

            if [[ "$POST_CHECK" == "1" ]]; then
              dc_yaml2="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
              pod2="$(wait_for_ready_pod "$ns" "$dc" "$dc_yaml2" | tr -d '\r')"
              if [[ -n "$pod2" ]]; then
                pod_name="$pod2"

                # container name re-check via API
                container_name2="$(get_dc_first_container_name "$ns" "$dc")"
                [[ -z "$container_name2" ]] && container_name2="$container_name"

                java_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -c "$container_name2" -- java -version || true)"
                if echo "$java_out2" | grep -qiE '(container .* is not valid|container not found|BadRequest)'; then
                  log_pod_container_list "$ns" "$dc" "$pod2"
                fi
                java_ver="$(echo "$java_out2" | head -n 2 | sanitize_one_line)"
                [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed_post"

                jcmd_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -c "$container_name2" -- jcmd 1 VM.flags || true)"
                if echo "$jcmd_out2" | grep -qiE '(container .* is not valid|container not found|BadRequest)'; then
                  log_pod_container_list "$ns" "$dc" "$pod2"
                fi
                jcmd_flags="$(echo "$jcmd_out2" | sanitize_one_line)"
                [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing_post"
              else
                log "WARN" "ns=${ns} dc=${dc} :: post-check couldn't find READY pod after rollout (timeout=${POD_WAIT_TIMEOUT})."
              fi
            fi
          fi
        fi
      else
        if [[ "$has_app" == "1" ]]; then
          apply_result="SKIP:already_JAVA_OPTS_APPEND"
        else
          apply_result="SKIP:no_JAVA_OPTIONS"
        fi
      fi
    fi

    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
      "$ns" "$dc" "$java_keys" "$target_present" "$pod_name" "$java_ver" "$jcmd_flags" "$apply_result"

  done <<< "$dc_list"

done <<< "$NS_LIST_RAW"

log "INFO" "Completed mode=${MODE}"
log "INFO" "Log saved to ${LOG_FILE}"


⸻

Çalıştırma (senin senaryo)

Önce list ile doğrula:

./oc_dc_java_audit.sh list -n accounts-dev --dc digital-accounts-composition-v0

Sonra dry-run:

./oc_dc_java_audit.sh apply -n accounts-dev --dc digital-accounts-composition-v0 --dry-run

Sonra gerçek apply:

./oc_dc_java_audit.sh apply -n accounts-dev --dc digital-accounts-composition-v0

Bu versiyonda ENV container hatası tekrar oluşmaz. Oluşursa zaten log’da pod container listesi otomatik basılacak.