Haklısın. Şu an olan şey: DC template’inde JAVA_OPTIONS hâlâ duruyor + ayrıca JAVA_OPTS_APPEND de eklenmiş görünüyor. Senin istediğin ise net:
	•	JAVA_OPTIONS env entry tamamen kalkacak
	•	aynı value ile JAVA_OPTS_APPEND olarak kalacak
	•	value’ye dokunulmayacak
	•	apply sonrası rollout zorunlu (DC için oc rollout latest dc/<dc>)

Ayrıca output’unda W0xxx warnings.go satırları yine “APPLY_RESULT” kolonuna karışmış; bu da oc apply stderr’ini tabloya basmandan kaynaklı. Apply sonucunu tabloya basarken sadece stdout’u alıp stderr’i loga yazacağız.

Aşağıda bu ihtiyaçlara göre final script (tamamı) var. Özet farklar:

Bu scriptin davranışı
	•	apply modunda:
	1.	DC YAML alınır
	2.	JAVA_OPTIONS env entry’si JAVA_OPTS_APPEND olarak rename edilir (ekleme yok, “duplicate” yok)
	3.	oc apply -f ile uygulanır
	4.	oc rollout latest dc/<dc> çalıştırılır
	5.	(İsteğe bağlı) rollout sonrası yeni running pod bulunur, tekrar java -version ve jcmd 1 VM.flags okunur (post-check)
	•	list modunda değişiklik yapmaz.
	•	Güvenlik: apply için -n <ns> zorunlu.
	•	Log: her komut + timestamp, stderr dahil loga düşer. Tabloya “temiz” veri basılır.

⸻

✅ Final Script (JAVA_OPTIONS -> JAVA_OPTS_APPEND “rename”, rollout + post-check)

#!/usr/bin/env bash
set -u
IFS=$'\n\t'

MODE="${1:-}"
shift || true

NS_FILTER=""
DC_FILTER=""
DRY_RUN="0"
LIMIT_DCS="0"
INCLUDE_NS_REGEX=""
EXCLUDE_NS_REGEX=""
POST_CHECK="1"          # apply sonrası yeni poddan tekrar oku
ROLLOUT_TIMEOUT="180s"  # rollout status bekleme süresi

usage() {
  cat <<'EOF'
Usage:
  oc_dc_java_audit.sh {list|apply} [options]

Options:
  --namespace, -n <ns>          Only this namespace (REQUIRED for apply)
  --dc <dc-name>               Only this DeploymentConfig name (within namespace)
  --dry-run                    Apply mode: do not oc apply / rollout; just report would-change
  --limit <N>                  Process at most N DCs per run
  --include-ns-regex <regex>   Only namespaces matching regex
  --exclude-ns-regex <regex>   Skip namespaces matching regex
  --no-post-check              Apply mode: skip post-rollout java/jcmd checks
  --rollout-timeout <dur>      Rollout status wait time (default 180s), e.g. 120s

Examples:
  ./oc_dc_java_audit.sh list
  ./oc_dc_java_audit.sh list -n fin-accnt-mngmt-lab
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dry-run --dc product-channel-v0
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dc product-channel-v0
EOF
}

if [[ "$MODE" != "list" && "$MODE" != "apply" ]]; then
  usage
  exit 2
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --namespace|-n) NS_FILTER="${2:-}"; shift 2;;
    --dc) DC_FILTER="${2:-}"; shift 2;;
    --dry-run) DRY_RUN="1"; shift;;
    --limit) LIMIT_DCS="${2:-0}"; shift 2;;
    --include-ns-regex) INCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --exclude-ns-regex) EXCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --no-post-check) POST_CHECK="0"; shift;;
    --rollout-timeout) ROLLOUT_TIMEOUT="${2:-180s}"; shift 2;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown argument: $1"; usage; exit 2;;
  esac
done

if [[ "$MODE" == "apply" && -z "$NS_FILTER" ]]; then
  echo "ERROR: apply mode requires --namespace <ns> for safety."
  exit 5
fi

TS="$(date +%Y%m%d_%H%M%S)"
LOG_FILE="./oc_dc_java_audit_${MODE}_${TS}.log"

log() {
  local lvl="$1"; shift
  printf "%s [%s] %s\n" "$(date -Is)" "$lvl" "$*" | tee -a "$LOG_FILE" >/dev/null
}

# run_cmd <ns> <dc> <quiet_stderr:0|1> -- <command...>
# quiet_stderr=1: stderr -> /dev/null (for jsonpath listing; avoid warnings breaking parse)
# quiet_stderr=0: capture stdout+stderr (for exec; java -version uses stderr)
run_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  local quiet="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (quiet_stderr=${quiet})"

  local out rc
  if [[ "$quiet" == "1" ]]; then
    out="$("${cmd[@]}" 2>/dev/null)" || rc=$?
  else
    out="$("${cmd[@]}" 2>&1)" || rc=$?
  fi
  rc="${rc:-0}"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} :: ${out}"
    printf "%s" "$out"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} :: $(echo "$out" | head -n 1 | tr -d '\r')"
  printf "%s" "$out"
  return 0
}

# run_apply_cmd: stdout to function output, stderr only to log (not to table)
run_apply_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_apply_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (stdout only to caller; stderr -> log)"

  local stdout tmp_err rc
  tmp_err="$(mktemp)"
  stdout="$("${cmd[@]}" 2>"$tmp_err")" || rc=$?
  rc="${rc:-0}"

  if [[ -s "$tmp_err" ]]; then
    log "WARN" "ns=${ns} dc=${dc} stderr :: $(cat "$tmp_err" | head -n 3 | tr -d '\r')"
    # full stderr log
    while read -r line; do
      [[ -n "$line" ]] && log "STDERR" "ns=${ns} dc=${dc} :: $line"
    done < "$tmp_err"
  fi
  rm -f "$tmp_err"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} stdout :: ${stdout}"
    printf "%s" "$stdout"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} stdout :: $(echo "$stdout" | head -n 1 | tr -d '\r')"
  printf "%s" "$stdout"
  return 0
}

require_oc_login() {
  command -v oc >/dev/null 2>&1 || { echo "ERROR: oc not found in PATH" >&2; exit 10; }
  local out rc
  out="$(oc whoami 2>&1)" || rc=$?
  rc="${rc:-0}"
  if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: oc is not logged in. oc whoami failed: $out" >&2
    exit 3
  fi
}

sanitize_one_line() { tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/ $//'; }

# Extract selector from DC YAML spec.selector (key=value,key2=value2)
dc_selector_from_yaml() {
  awk '
    BEGIN{spec=0; inSel=0}
    /^spec:/ {spec=1}
    spec && /^[[:space:]]+selector:/ {inSel=1; next}
    inSel {
      if ($0 ~ /^[[:space:]]{4}[A-Za-z0-9_.-]+:[[:space:]]*[A-Za-z0-9_.-]+[[:space:]]*$/) {
        gsub(/^[[:space:]]+/, "", $0)
        split($0,a,":")
        k=a[1]; v=a[2]
        gsub(/[[:space:]]+/, "", v)
        if (k != "" && v != "") {
          if (out != "") out=out ","
          out=out k "=" v
        }
        next
      }
      if ($0 !~ /^[[:space:]]{4}/) {inSel=0}
    }
    END{print out}
  '
}

find_one_pod_for_dc() {
  local ns="$1"
  local dc="$2"
  local dc_yaml="$3"

  local pods
  pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "deploymentconfig=$dc" \
    --field-selector=status.phase=Running \
    -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  if [[ -n "$pods" ]]; then
    echo "$pods" | head -n 1
    return 0
  fi

  local sel
  sel="$(printf "%s" "$dc_yaml" | dc_selector_from_yaml | tr -d '\r')"
  if [[ -n "$sel" ]]; then
    pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "$sel" \
      --field-selector=status.phase=Running \
      -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
    if [[ -n "$pods" ]]; then
      echo "$pods" | head -n 1
      return 0
    fi
  fi

  echo ""
  return 0
}

# Transform DC YAML: rename env name JAVA_OPTIONS -> JAVA_OPTS_APPEND (no duplication, value unchanged)
# Works on the env list entry lines like:
#   - name: JAVA_OPTIONS
# It ONLY changes that line, keeps the following value/valueFrom intact.
transform_java_options_to_append() {
  # stdin: YAML
  # stdout: YAML (transformed)
  sed -E 's/^([[:space:]]*-[[:space:]]name:[[:space:]]*)JAVA_OPTIONS([[:space:]]*)$/\1JAVA_OPTS_APPEND\2/'
}

# Detect whether the DC YAML has env entry "name: JAVA_OPTIONS"
has_java_options_env() {
  grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$'
}

# Detect JAVA_* env keys present (informational)
extract_java_env_keys() {
  grep -E '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA(_[A-Z0-9_]+)?[[:space:]]*$' \
    | sed -E 's/.*name:[[:space:]]*//g' \
    | sort -u \
    | paste -sd ',' - \
    | sed -E 's/^$/-/'
}

: > "$LOG_FILE"
log "INFO" "Started mode=${MODE} log=${LOG_FILE} ns=${NS_FILTER:-} dc=${DC_FILTER:-} dry_run=${DRY_RUN} post_check=${POST_CHECK} rollout_timeout=${ROLLOUT_TIMEOUT}"
require_oc_login
log "INFO" "oc whoami=$(oc whoami 2>/dev/null)"

# TSV header
printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
  "NAMESPACE" "DEPLOYMENTCONFIG" "JAVA_ENV_KEYS" "TARGET_ENV_PRESENT" "POD" "JAVA_VERSION" "JCMD_VM_FLAGS" "APPLY_RESULT"

# Namespace list (quiet stderr to avoid warnings polluting parse)
NS_LIST_RAW="$(run_cmd "-" "-" 1 -- oc get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
if [[ -z "$NS_LIST_RAW" ]]; then
  log "ERR" "No namespaces returned."
  exit 4
fi

while read -r ns; do
  [[ -z "$ns" ]] && continue

  [[ -n "$NS_FILTER" && "$ns" != "$NS_FILTER" ]] && continue
  if [[ -n "$INCLUDE_NS_REGEX" ]] && ! echo "$ns" | grep -Eq "$INCLUDE_NS_REGEX"; then continue; fi
  if [[ -n "$EXCLUDE_NS_REGEX" ]] && echo "$ns" | grep -Eq "$EXCLUDE_NS_REGEX"; then continue; fi

  dc_list="$(run_cmd "$ns" "-" 1 -- oc get dc -n "$ns" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  [[ -z "$dc_list" ]] && continue

  dc_processed=0
  while read -r dc; do
    [[ -z "$dc" ]] && continue
    [[ -n "$DC_FILTER" && "$dc" != "$DC_FILTER" ]] && continue

    dc_processed=$((dc_processed+1))
    if [[ "$LIMIT_DCS" -gt 0 && "$dc_processed" -gt "$LIMIT_DCS" ]]; then
      log "INFO" "ns=${ns} :: reached --limit ${LIMIT_DCS}, stopping."
      break
    fi

    dc_yaml="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
    if [[ -z "$dc_yaml" ]]; then
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$ns" "$dc" "ERROR:dc_yaml_unreadable" "-" "-" "-" "-" "-"
      continue
    fi

    java_keys="$(printf "%s" "$dc_yaml" | extract_java_env_keys)"
    target_present="none"
    if printf "%s" "$dc_yaml" | grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$'; then
      target_present="JAVA_OPTIONS"
    elif printf "%s" "$dc_yaml" | grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTS_APPEND[[:space:]]*$'; then
      target_present="JAVA_OPTS_APPEND"
    fi

    # Pre-check pod (best-effort)
    pod_name="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml" | tr -d '\r')"
    java_ver="-"
    jcmd_flags="-"
    if [[ -n "$pod_name" ]]; then
      java_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -- java -version || true)"
      java_ver="$(echo "$java_out" | head -n 2 | sanitize_one_line)"
      [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed"

      jcmd_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -- jcmd 1 VM.flags || true)"
      jcmd_flags="$(echo "$jcmd_out" | sanitize_one_line)"
      [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing"
    else
      pod_name="-"
      java_ver="WARN:no_running_pod_found"
      jcmd_flags="WARN:no_running_pod_found"
    fi

    apply_result="-"
    if [[ "$MODE" == "apply" ]]; then
      if printf "%s" "$dc_yaml" | has_java_options_env; then
        tmp_out="$(mktemp)"
        printf "%s" "$dc_yaml" | transform_java_options_to_append > "$tmp_out"

        # sanity check: ensure JAVA_OPTIONS entry is gone and JAVA_OPTS_APPEND exists
        if grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$' "$tmp_out"; then
          apply_result="ERROR:transform_failed_java_options_still_present"
          log "ERR" "ns=${ns} dc=${dc} :: transform failed (JAVA_OPTIONS still present)."
          rm -f "$tmp_out"
        elif ! grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTS_APPEND[[:space:]]*$' "$tmp_out"; then
          apply_result="ERROR:transform_failed_no_java_opts_append"
          log "ERR" "ns=${ns} dc=${dc} :: transform failed (JAVA_OPTS_APPEND not found)."
          rm -f "$tmp_out"
        else
          if [[ "$DRY_RUN" == "1" ]]; then
            apply_result="DRYRUN:would_apply_and_rollout"
            log "INFO" "ns=${ns} dc=${dc} :: DRY-RUN: would oc apply + rollout latest."
            rm -f "$tmp_out"
          else
            # Apply (stdout only to apply_result; stderr goes to log so warnings don't pollute table)
            apply_out="$(run_apply_cmd "$ns" "$dc" -- oc apply -n "$ns" -f "$tmp_out" || true)"
            rm -f "$tmp_out"

            # Rollout latest (must)
            rollout_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout latest -n "$ns" "dc/${dc}" || true)"

            # Wait for rollout status (best-effort)
            status_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout status -n "$ns" "dc/${dc}" --timeout="${ROLLOUT_TIMEOUT}" || true)"

            # Compose apply_result
            # Keep it short for table, detailed logs already exist
            if echo "$apply_out" | grep -qiE '(configured|created|unchanged)'; then
              apply_result="APPLIED+ROLLEDOUT"
            else
              apply_result="ERROR:apply_or_rollout_failed"
            fi

            # Post-check: after rollout, re-find running pod and re-read java/jcmd
            if [[ "$POST_CHECK" == "1" ]]; then
              # Refresh DC YAML (quiet)
              dc_yaml2="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
              pod2="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml2" | tr -d '\r')"
              if [[ -n "$pod2" ]]; then
                # overwrite columns with post-check results
                pod_name="$pod2"

                java_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -- java -version || true)"
                java_ver="$(echo "$java_out2" | head -n 2 | sanitize_one_line)"
                [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed_post"

                jcmd_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -- jcmd 1 VM.flags || true)"
                jcmd_flags="$(echo "$jcmd_out2" | sanitize_one_line)"
                [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing_post"
              else
                log "WARN" "ns=${ns} dc=${dc} :: post-check couldn't find running pod after rollout."
              fi
            fi
          fi
        fi
      else
        apply_result="SKIP:no_JAVA_OPTIONS"
      fi
    fi

    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
      "$ns" "$dc" "$java_keys" "$target_present" "$pod_name" "$java_ver" "$jcmd_flags" "$apply_result"

  done <<< "$dc_list"

done <<< "$NS_LIST_RAW"

log "INFO" "Completed mode=${MODE}"
log "INFO" "Log saved to ${LOG_FILE}"


⸻

Neden sende “JAVA_OPTIONS + JAVA_OPTS_APPEND birlikte” oldu?

Senin gönderdiğin “after” pod YAML’da env index’inde hem JAVA_OPTS_APPEND hem JAVA_OPTIONS var. Bu, DC template’inde muhtemelen:
	•	bir yerde zaten JAVA_OPTS_APPEND vardı (ör. başka container/env block) ve script JAVA_OPTIONS’ı silmek yerine ekleme/duplicate gibi bir şeye yol açtı,
	•	ya da apply’den sonra image/entrypoint tarafı JAVA_OPTIONS’ı otomatik ekliyor (bazı base image’lar JAVA_OPTIONS’ı “default env” olarak inject edebilir). Ama senin YAML’da “env:” listesinde açıkça göründüğü için büyük ihtimalle DC template env listesinde iki entry var.

Bu final script JAVA_OPTIONS satırını rename eder, dolayısıyla DC template’inde “iki entry” oluşmaz.

Not: Eğer image entrypoint kendisi runtime’da JAVA_OPTIONS env’ini set ediyorsa, o zaman DC’de olmasa bile container env’inde görünebilir. Bunu anlamanın yolu: DC YAML’ında gerçekten JAVA_OPTIONS var mı bakmak. Bu script apply sonrası tekrar DC YAML çektiği için bunu logdan da görürsün.

⸻

Kullanım (senin senaryona birebir)

Önce dry-run:

./oc_dc_java_audit.sh apply -n ges-life-product-test --dc product-channel-v0 --dry-run

Sonra gerçek:

./oc_dc_java_audit.sh apply -n ges-life-product-test --dc product-channel-v0

Bu çalışınca:
	•	DC’de JAVA_OPTIONS entry kalmamalı
	•	rollout latest tetiklenmeli
	•	yeni podda env | grep JAVA_ çıktısında JAVA_OPTS_APPEND olmalı; JAVA_OPTIONS DC’den kalkmış olmalı.

İstersen bir sonraki adımda script’e şunu da ekleyebiliriz:
	•	Post-check olarak oc get dc -o yaml içinden env listesinde JAVA_OPTIONS kaldı mı? kalırsa “FAIL” yazıp script exit code ile hata versin (pipeline için).