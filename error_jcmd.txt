[gbaocp01]~$./oc_dc_java_audit.sh list -n access-and-signature-mgmt-test --dc cust-transaction-log-data-v2
NAMESPACE       DEPLOYMENTCONFIG        JAVA_ENV_KEYS   TARGET_ENV_PRESENT      POD     JAVA_VERSION    JCMD_VM_FLAGS   APPLY_RESULT
./oc_dc_java_audit.sh: line 445: syntax error near unexpected token `else'
./oc_dc_java_audit.sh: line 445: `            else'
[gbaocp01]~$./oc_dc_java_audit.sh apply -n access-and-signature-mgmt-test --dc cust-transaction-log-data-v2 --dry-run
NAMESPACE       DEPLOYMENTCONFIG        JAVA_ENV_KEYS   TARGET_ENV_PRESENT      POD     JAVA_VERSION    JCMD_VM_FLAGS   APPLY_RESULT
./oc_dc_java_audit.sh: line 445: syntax error near unexpected token `else'
./oc_dc_java_audit.sh: line 445: `            else'
[gbaocp01]~$cat oc_dc_java_audit.sh 
#!/usr/bin/env bash
set -u
IFS=$'\n\t'

MODE="${1:-}"
shift || true

NS_FILTER=""
DC_FILTER=""
DRY_RUN="0"
LIMIT_DCS="0"
INCLUDE_NS_REGEX=""
EXCLUDE_NS_REGEX=""
POST_CHECK="1"
ROLLOUT_TIMEOUT="180s"
POD_WAIT_TIMEOUT="120s"   # rollout sonrasÃ½ing+ready pod bulmak iÃ§ bekleme
POD_WAIT_INTERVAL="5s"

usage() {
  cat <<'EOF'
Usage:
  oc_dc_java_audit.sh {list|apply} [options]

Options:
  --namespace, -n <ns>          Only this namespace (REQUIRED for apply)
  --dc <dc-name>               Only this DeploymentConfig name (within namespace)
  --dry-run                    Apply mode: do not oc apply / rollout; just report would-change
  --limit <N>                  Process at most N DCs per run
  --include-ns-regex <regex>   Only namespaces matching regex
  --exclude-ns-regex <regex>   Skip namespaces matching regex
  --no-post-check              Apply mode: skip post-rollout java/jcmd checks
  --rollout-timeout <dur>      Rollout status wait time (default 180s), e.g. 120s
  --pod-wait-timeout <dur>     Post-rollout pod wait timeout (default 120s)
  --pod-wait-interval <dur>    Post-rollout poll interval (default 5s)

Examples:
  ./oc_dc_java_audit.sh list
  ./oc_dc_java_audit.sh list -n fin-accnt-mngmt-lab
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dry-run --dc product-channel-v0
  ./oc_dc_java_audit.sh apply -n ges-life-product-test --dc product-channel-v0
EOF
}

if [[ "$MODE" != "list" && "$MODE" != "apply" ]]; then
  usage
  exit 2
fi

while [[ $# -gt 0 ]]; do
  case "$1" in
    --namespace|-n) NS_FILTER="${2:-}"; shift 2;;
    --dc) DC_FILTER="${2:-}"; shift 2;;
    --dry-run) DRY_RUN="1"; shift;;
    --limit) LIMIT_DCS="${2:-0}"; shift 2;;
    --include-ns-regex) INCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --exclude-ns-regex) EXCLUDE_NS_REGEX="${2:-}"; shift 2;;
    --no-post-check) POST_CHECK="0"; shift;;
    --rollout-timeout) ROLLOUT_TIMEOUT="${2:-180s}"; shift 2;;
    --pod-wait-timeout) POD_WAIT_TIMEOUT="${2:-120s}"; shift 2;;
    --pod-wait-interval) POD_WAIT_INTERVAL="${2:-5s}"; shift 2;;
    -h|--help) usage; exit 0;;
    *) echo "Unknown argument: $1"; usage; exit 2;;
  esac
done

if [[ "$MODE" == "apply" && -z "$NS_FILTER" ]]; then
  echo "ERROR: apply mode requires --namespace <ns> for safety."
  exit 5
fi

TS="$(date +%Y%m%d_%H%M%S)"
LOG_FILE="./oc_dc_java_audit_${MODE}_${TS}.log"

log() {
  local lvl="$1"; shift
  printf "%s [%s] %s\n" "$(date -Is)" "$lvl" "$*" | tee -a "$LOG_FILE" >/dev/null
}

# run_cmd <ns> <dc> <quiet_stderr:0|1> -- <command...>
run_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  local quiet="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (quiet_stderr=${quiet})"

  local out rc
  if [[ "$quiet" == "1" ]]; then
    out="$("${cmd[@]}" 2>/dev/null)" || rc=$?
  else
    out="$("${cmd[@]}" 2>&1)" || rc=$?
  fi
  rc="${rc:-0}"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} :: ${out}"
    printf "%s" "$out"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} :: $(echo "$out" | head -n 1 | tr -d '\r')"
  printf "%s" "$out"
  return 0
}

# run_apply_cmd: stdout to function output, stderr only to log (not to table)
run_apply_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_apply_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift
  local -a cmd=( "$@" )

  local pretty="" i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"
  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (stdout only to caller; stderr -> log)"

  local stdout tmp_err rc
  tmp_err="$(mktemp)"
  stdout="$("${cmd[@]}" 2>"$tmp_err")" || rc=$?
  rc="${rc:-0}"

  if [[ -s "$tmp_err" ]]; then
    log "WARN" "ns=${ns} dc=${dc} stderr :: $(cat "$tmp_err" | head -n 3 | tr -d '\r')"
    while read -r line; do
      [[ -n "$line" ]] && log "STDERR" "ns=${ns} dc=${dc} :: $line"
    done < "$tmp_err"
  fi
  rm -f "$tmp_err"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} stdout :: ${stdout}"
    printf "%s" "$stdout"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} stdout :: $(echo "$stdout" | head -n 1 | tr -d '\r')"
  printf "%s" "$stdout"
  return 0
}

require_oc_login() {
  command -v oc >/dev/null 2>&1 || { echo "ERROR: oc not found in PATH" >&2; exit 10; }
  local out rc
  out="$(oc whoami 2>&1)" || rc=$?
  rc="${rc:-0}"
  if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: oc is not logged in. oc whoami failed: $out" >&2
    exit 3
  fi
}

sanitize_one_line() { tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/ $//'; }

# Extract selector from DC YAML spec.selector (key=value,key2=value2)
dc_selector_from_yaml() {
  awk '
    BEGIN{spec=0; inSel=0}
    /^spec:/ {spec=1}
    spec && /^[[:space:]]+selector:/ {inSel=1; next}
    inSel {
      if ($0 ~ /^[[:space:]]{4}[A-Za-z0-9_.-]+:[[:space:]]*[A-Za-z0-9_.-]+[[:space:]]*$/) {
        gsub(/^[[:space:]]+/, "", $0)
        split($0,a,":")
        k=a[1]; v=a[2]
        gsub(/[[:space:]]+/, "", v)
        if (k != "" && v != "") {
          if (out != "") out=out ","
          out=out k "=" v
        }
        next
      }
      if ($0 !~ /^[[:space:]]{4}/) {inSel=0}
    }
    END{print out}
  '
}

# Container name: first container under spec.template.spec.containers[].name
dc_first_container_name_from_yaml() {
  awk '
    BEGIN{inSpec=0; inTpl=0; inC=0}
    /^spec:/ {inSpec=1}
    inSpec && /^[[:space:]]+template:/ {inTpl=1}
    inTpl && /^[[:space:]]+containers:/ {inC=1; next}
    inC {
      if ($0 ~ /^[[:space:]]*-[[:space:]]name:[[:space:]]*[^[:space:]]+/) {
        gsub(/^[[:space:]]*-[[:space:]]name:[[:space:]]*/, "", $0)
        print $0
        exit
      }
      # stop if we leave containers block
      if ($0 !~ /^[[:space:]]{6}/ && $0 !~ /^[[:space:]]{8}/ && $0 !~ /^[[:space:]]{10}/) { }
    }
  ' | tr -d '\r'
}

find_one_pod_for_dc() {
  local ns="$1"
  local dc="$2"
  local dc_yaml="$3"

  local pods
  pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "deploymentconfig=$dc" \
    --field-selector=status.phase=Running \
    -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  if [[ -n "$pods" ]]; then
    echo "$pods" | head -n 1
    return 0
  fi

  local sel
  sel="$(printf "%s" "$dc_yaml" | dc_selector_from_yaml | tr -d '\r')"
  if [[ -n "$sel" ]]; then
    pods="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "$sel" \
      --field-selector=status.phase=Running \
      -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
    if [[ -n "$pods" ]]; then
      echo "$pods" | head -n 1
      return 0
    fi
  fi

  echo ""
  return 0
}

# Wait until we have a running+ready pod (best-effort)
wait_for_ready_pod() {
  local ns="$1"
  local dc="$2"
  local dc_yaml="$3"
  local timeout_s
  timeout_s="$(echo "$POD_WAIT_TIMEOUT" | sed -E 's/s$//')"
  [[ -z "$timeout_s" ]] && timeout_s="120"

  local elapsed=0
  while [[ "$elapsed" -le "$timeout_s" ]]; do
    local pod
    pod="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml" | tr -d '\r')"
    if [[ -n "$pod" ]]; then
      # ready?
      local ready
      ready="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" "$pod" -o jsonpath='{.status.containerStatuses[0].ready}' || true)"
      if [[ "$ready" == "true" ]]; then
        echo "$pod"
        return 0
      fi
    fi
    sleep "$POD_WAIT_INTERVAL"
    elapsed=$((elapsed + 5))
  done
  echo ""
  return 0
}

# Detect JAVA_* env keys present (informational)
extract_java_env_keys() {
  grep -E '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA(_[A-Z0-9_]+)?[[:space:]]*$' \
    | sed -E 's/.*name:[[:space:]]*//g' \
    | sort -u \
    | paste -sd ',' - \
    | sed -E 's/^$/-/'
}

has_java_options_env() {
  grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$'
}
has_java_opts_append_env() {
  grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTS_APPEND[[:space:]]*$'
}

# Case A: only JAVA_OPTIONS exists  -> RENAME that item to JAVA_OPTS_APPEND (value/valueFrom untouched)
rename_java_options_to_append() {
  sed -E 's/^([[:space:]]*-[[:space:]]name:[[:space:]]*)JAVA_OPTIONS([[:space:]]*)$/\1JAVA_OPTS_APPEND\2/'
}

# Case B: JAVA_OPTIONS and JAVA_OPTS_APPEND both exist -> REMOVE the whole JAVA_OPTIONS item block (do NOT duplicate)
remove_java_options_item() {
  awk '
    BEGIN{skip=0; indent=""; first=1}
    {
      line=$0
      if (skip==0) {
        if (match(line, /^([[:space:]]*)-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$/, m)) {
          indent=m[1]
          skip=1
          next
        }
        print line
        next
      } else {
        # skip until next item at same indent: "<indent>- name:"
        pat="^" indent "-[[:space:]]name:[[:space:]]"
        if (line ~ pat) {
          skip=0
          print line
          next
        }
        next
      }
    }
  '
}

: > "$LOG_FILE"
log "INFO" "Started mode=${MODE} log=${LOG_FILE} ns=${NS_FILTER:-} dc=${DC_FILTER:-} dry_run=${DRY_RUN} post_check=${POST_CHECK} rollout_timeout=${ROLLOUT_TIMEOUT}"
require_oc_login
log "INFO" "oc whoami=$(oc whoami 2>/dev/null)"

# TSV header
printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
  "NAMESPACE" "DEPLOYMENTCONFIG" "JAVA_ENV_KEYS" "TARGET_ENV_PRESENT" "POD" "JAVA_VERSION" "JCMD_VM_FLAGS" "APPLY_RESULT"

NS_LIST_RAW="$(run_cmd "-" "-" 1 -- oc get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
if [[ -z "$NS_LIST_RAW" ]]; then
  log "ERR" "No namespaces returned."
  exit 4
fi

while read -r ns; do
  [[ -z "$ns" ]] && continue

  [[ -n "$NS_FILTER" && "$ns" != "$NS_FILTER" ]] && continue
  if [[ -n "$INCLUDE_NS_REGEX" ]] && ! echo "$ns" | grep -Eq "$INCLUDE_NS_REGEX"; then continue; fi
  if [[ -n "$EXCLUDE_NS_REGEX" ]] && echo "$ns" | grep -Eq "$EXCLUDE_NS_REGEX"; then continue; fi

  dc_list="$(run_cmd "$ns" "-" 1 -- oc get dc -n "$ns" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  [[ -z "$dc_list" ]] && continue

  dc_processed=0
  while read -r dc; do
    [[ -z "$dc" ]] && continue
    [[ -n "$DC_FILTER" && "$dc" != "$DC_FILTER" ]] && continue

    dc_processed=$((dc_processed+1))
    if [[ "$LIMIT_DCS" -gt 0 && "$dc_processed" -gt "$LIMIT_DCS" ]]; then
      log "INFO" "ns=${ns} :: reached --limit ${LIMIT_DCS}, stopping."
      break
    fi

    dc_yaml="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
    if [[ -z "$dc_yaml" ]]; then
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$ns" "$dc" "ERROR:dc_yaml_unreadable" "-" "-" "-" "-" "-"
      continue
    fi

    java_keys="$(printf "%s" "$dc_yaml" | extract_java_env_keys)"

    # TARGET_ENV_PRESENT: more explicit
    target_present="none"
    has_opt="0"; has_app="0"
    if printf "%s" "$dc_yaml" | has_java_options_env; then has_opt="1"; fi
    if printf "%s" "$dc_yaml" | has_java_opts_append_env; then has_app="1"; fi
    if [[ "$has_opt" == "1" && "$has_app" == "1" ]]; then
      target_present="JAVA_OPTIONS+JAVA_OPTS_APPEND"
    elif [[ "$has_opt" == "1" ]]; then
      target_present="JAVA_OPTIONS"
    elif [[ "$has_app" == "1" ]]; then
      target_present="JAVA_OPTS_APPEND"
    fi

    # Container name for oc exec (-c) to avoid "container not found" surprises
    container_name="$(printf "%s" "$dc_yaml" | dc_first_container_name_from_yaml)"
    [[ -z "$container_name" ]] && container_name="$dc"   # fallback

    # Pre-check pod
    pod_name="$(find_one_pod_for_dc "$ns" "$dc" "$dc_yaml" | tr -d '\r')"
    java_ver="-"
    jcmd_flags="-"
    if [[ -n "$pod_name" ]]; then
      java_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -c "$container_name" -- java -version || true)"
      java_ver="$(echo "$java_out" | head -n 2 | sanitize_one_line)"
      [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed"

      jcmd_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -c "$container_name" -- jcmd 1 VM.flags || true)"
      jcmd_flags="$(echo "$jcmd_out" | sanitize_one_line)"
      [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing"
    else
      pod_name="-"
      java_ver="WARN:no_running_pod_found"
      jcmd_flags="WARN:no_running_pod_found"
    fi

    apply_result="-"
    if [[ "$MODE" == "apply" ]]; then
      if [[ "$has_opt" == "1" ]]; then
        tmp_out="$(mktemp)"

        # --- TRANSFORM RULES (senin istediÃ°FINAL davranÃ½-
        # 1) EÃ°sadece JAVA_OPTIONS varsa: onu JAVA_OPTS_APPEND'e Ã‡VÃ (value sabit)
        # 2) EÃ°JAVA_OPTIONS + JAVA_OPTS_APPEND birlikte varsa: JAVA_OPTIONS entry'sini SÃ (duplicate olmasÃ½      if [[ "$has_app" == "1" ]]; then
          # remove JAVA_OPTIONS item entirely
          printf "%s" "$dc_yaml" | remove_java_options_item > "$tmp_out"
        else
          # rename JAVA_OPTIONS -> JAVA_OPTS_APPEND
          printf "%s" "$dc_yaml" | rename_java_options_to_append > "$tmp_out"
        fi

        # sanity: ensure JAVA_OPTIONS is gone
        if grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$' "$tmp_out"; then
          apply_result="ERROR:transform_failed_java_options_still_present"
          log "ERR" "ns=${ns} dc=${dc} :: transform failed (JAVA_OPTIONS still present)."
          rm -f "$tmp_out"
        else
          if [[ "$DRY_RUN" == "1" ]]; then
            apply_result="DRYRUN:would_apply_and_rollout"
            log "INFO" "ns=${ns} dc=${dc} :: DRY-RUN: would oc apply + rollout latest."
            rm -f "$tmp_out"
          else
            apply_out="$(run_apply_cmd "$ns" "$dc" -- oc apply -n "$ns" -f "$tmp_out" || true)"
            rm -f "$tmp_out"

            rollout_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout latest -n "$ns" "dc/${dc}" || true)"
            status_out="$(run_apply_cmd "$ns" "$dc" -- oc rollout status -n "$ns" "dc/${dc}" --timeout="${ROLLOUT_TIMEOUT}" || true)"

            # apply_result: rollout status SUCCESS kontrolÃ¼        if echo "$status_out" | grep -qiE '(successfully rolled out|rolled out)'; then
              apply_result="APPLIED+ROLLEDOUT"
            else
              apply_result="APPLIED_BUT_ROLLOUT_PENDING"
            fi

            # Post-check: rollout tamamlandÃ½a da best-effort pod ready bekleyip tekrar oku
            if [[ "$POST_CHECK" == "1" ]]; then
              dc_yaml2="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
              pod2="$(wait_for_ready_pod "$ns" "$dc" "$dc_yaml2" | tr -d '\r')"
              if [[ -n "$pod2" ]]; then
                pod_name="$pod2"

                # container name re-read (in case template changed)
                container_name2="$(printf "%s" "$dc_yaml2" | dc_first_container_name_from_yaml)"
                [[ -z "$container_name2" ]] && container_name2="$container_name"

                java_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -c "$container_name2" -- java -version || true)"
                java_ver="$(echo "$java_out2" | head -n 2 | sanitize_one_line)"
                [[ -z "$java_ver" ]] && java_ver="ERROR:java_version_failed_post"

                jcmd_out2="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod2" -c "$container_name2" -- jcmd 1 VM.flags || true)"
                jcmd_flags="$(echo "$jcmd_out2" | sanitize_one_line)"
                [[ -z "$jcmd_flags" ]] && jcmd_flags="ERROR:jcmd_failed_or_missing_post"
              else
                log "WARN" "ns=${ns} dc=${dc} :: post-check couldn't find READY pod after rollout (timeout=${POD_WAIT_TIMEOUT})."
                # burada tabloyu bozmuyoruz, log yeterli
              fi
            fi
          fi
        fi
      else
        # JAVA_OPTIONS yoksa: zaten hedef yok; SKIP (istersen ayrÃ½VA_OPTS_APPEND varsa "OK" diyebilirsin)
        if [[ "$has_app" == "1" ]]; then
          apply_result="SKIP:already_JAVA_OPTS_APPEND"
        else
          apply_result="SKIP:no_JAVA_OPTIONS"
        fi
      fi
    fi

    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
      "$ns" "$dc" "$java_keys" "$target_present" "$pod_name" "$java_ver" "$jcmd_flags" "$apply_result"

  done <<< "$dc_list"

done <<< "$NS_LIST_RAW"

log "INFO" "Completed mode=${MODE}"
log "INFO" "Log saved to ${LOG_FILE}"
[gbaocp01]~$
