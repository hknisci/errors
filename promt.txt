Bu sefer kök sebep farklı: oc get dc çıktısına (stderr) düşen “W0218 … warnings.go … deprecated” uyarısı, bizim run_cmd’nin çıktısını bozup dc adı gibi okunuyor. O yüzden DC ismi yerine W0218 03:25:... “dc” oluyor; sonra label selector da patlıyor.

Çözüm: Makine-parsable veri çekerken stderr’i tamamen sustur (warnings dahil). Yani oc get ... -o jsonpath=... 2>/dev/null (veya --loglevel=0 mümkünse) kullan.

Ayrıca ikinci sorun: pod seçerken jsonpath .items[0] boşsa “array index out of bounds” veriyor. Bunu da jsonpath ile range yaparak çözmek lazım (ilk podu range ile al, boşsa zaten boş string gelir).

Aşağıya tam düzeltilmiş, “warning’ler DC listesine karışmasın + pod selection güvenli olsun” sürümü veriyorum.

Not: Ben burada en güvenlisi olarak sadece “listeleme amaçlı” oc komutlarında stderr’i kapatıyorum. oc exec gibi komutlarda stderr’i kapatmıyorum (java -version zaten çoğu zaman stderr’e yazar), ama yine de stdout+stderr yakalıyoruz.

⸻

✅ Güncellenmiş script (warnings-proof + jsonpath-safe)

#!/usr/bin/env bash
set -u
IFS=$'\n\t'

MODE="${1:-}"
if [[ "$MODE" != "list" && "$MODE" != "apply" ]]; then
  echo "Usage: $0 {list|apply}"
  exit 2
fi

TS="$(date +%Y%m%d_%H%M%S)"
LOG_FILE="./oc_dc_java_audit_${MODE}_${TS}.log"

log() {
  local lvl="$1"; shift
  printf "%s [%s] %s\n" "$(date -Is)" "$lvl" "$*" | tee -a "$LOG_FILE" >/dev/null
}

# run_cmd <ns> <dc> <quiet_stderr:0|1> -- <command...>
run_cmd() {
  local ns="$1"; shift
  local dc="$1"; shift
  local quiet="$1"; shift

  if [[ "${1:-}" != "--" ]]; then
    log "ERR" "run_cmd usage error: missing -- delimiter"
    return 99
  fi
  shift

  local -a cmd=( "$@" )

  # pretty for log
  local pretty=""
  local i
  for i in "${cmd[@]}"; do
    if [[ "$i" =~ [[:space:]\'] ]]; then
      pretty+="'${i//\'/\'\\\'\'}' "
    else
      pretty+="$i "
    fi
  done
  pretty="${pretty% }"

  log "CMD" "ns=${ns} dc=${dc} :: ${pretty} (quiet_stderr=${quiet})"

  local out rc
  if [[ "$quiet" == "1" ]]; then
    out="$("${cmd[@]}" 2>/dev/null)" || rc=$?
  else
    out="$("${cmd[@]}" 2>&1)" || rc=$?
  fi
  rc="${rc:-0}"

  if [[ "$rc" -ne 0 ]]; then
    log "ERR" "ns=${ns} dc=${dc} rc=${rc} :: ${out}"
    printf "%s" "$out"
    return "$rc"
  fi

  log "OUT" "ns=${ns} dc=${dc} :: $(echo "$out" | head -n 1 | tr -d '\r')"
  printf "%s" "$out"
  return 0
}

require_oc_login() {
  local out rc
  out="$(oc whoami 2>&1)" || rc=$?
  rc="${rc:-0}"
  if [[ "$rc" -ne 0 ]]; then
    echo "ERROR: oc is not logged in or not configured. oc whoami failed: $out" >&2
    exit 3
  fi
}

sanitize_one_line() {
  tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g; s/ $//'
}

: > "$LOG_FILE"
log "INFO" "Started mode=${MODE} log=${LOG_FILE}"

command -v oc >/dev/null 2>&1 || { echo "ERROR: oc not found in PATH" >&2; exit 10; }
require_oc_login
log "INFO" "oc whoami=$(oc whoami 2>/dev/null)"

# TSV header
printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
  "NAMESPACE" "DEPLOYMENTCONFIG" "JAVA_ENV_KEYS" "POD" "JAVA_VERSION" "JCMD_VM_FLAGS" "APPLY_RESULT"

# Namespaces: quiet stderr (warnings must not pollute parsing)
NS_LIST_RAW="$(run_cmd "-" "-" 1 -- oc get ns -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
if [[ -z "$NS_LIST_RAW" ]]; then
  log "ERR" "No namespaces returned (or command failed). Exiting."
  exit 4
fi

while read -r ns; do
  [[ -z "$ns" ]] && continue

  # DC list: quiet stderr
  dc_list="$(run_cmd "$ns" "-" 1 -- oc get dc -n "$ns" -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' || true)"
  if [[ -z "$dc_list" ]]; then
    log "INFO" "ns=${ns} :: no DeploymentConfig found (or access denied)."
    continue
  fi

  while read -r dc; do
    [[ -z "$dc" ]] && continue

    # DC yaml: quiet stderr (same reason)
    dc_yaml="$(run_cmd "$ns" "$dc" 1 -- oc get dc "$dc" -n "$ns" -o yaml || true)"
    if [[ -z "$dc_yaml" ]]; then
      printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
        "$ns" "$dc" "ERROR:dc_yaml_unreadable" "-" "-" "-" "-"
      continue
    fi

    # Detect JAVA_* env names (best-effort grep)
    java_keys="$(echo "$dc_yaml" \
      | grep -E '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA(_[A-Z0-9_]+)?[[:space:]]*$' \
      | sed -E 's/.*name:[[:space:]]*//g' \
      | sort -u \
      | paste -sd ',' -)"
    [[ -z "$java_keys" ]] && java_keys="-"

    # Pick any running pod: SAFE jsonpath (no .items[0])
    # Try deploymentconfig label, then deployment label.
    pod_name="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "deploymentconfig=$dc" \
      --field-selector=status.phase=Running \
      -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' \
      | head -n 1 || true)"

    if [[ -z "$pod_name" ]]; then
      pod_name="$(run_cmd "$ns" "$dc" 1 -- oc get pod -n "$ns" -l "deployment=$dc" \
        --field-selector=status.phase=Running \
        -o jsonpath='{range .items[*]}{.metadata.name}{"\n"}{end}' \
        | head -n 1 || true)"
    fi

    java_ver="-"
    jcmd_flags="-"

    if [[ -n "$pod_name" ]]; then
      # exec outputs: do NOT quiet stderr (java -version usually uses stderr)
      java_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -- java -version || true)"
      if [[ -n "$java_out" ]]; then
        java_ver="$(echo "$java_out" | head -n 2 | sanitize_one_line)"
      else
        java_ver="ERROR:java_version_failed"
      fi

      jcmd_out="$(run_cmd "$ns" "$dc" 0 -- oc exec -n "$ns" "$pod_name" -- jcmd 1 VM.flags || true)"
      if [[ -n "$jcmd_out" ]]; then
        jcmd_flags="$(echo "$jcmd_out" | sanitize_one_line)"
      else
        jcmd_flags="ERROR:jcmd_failed_or_missing"
      fi
    else
      pod_name="-"
      java_ver="WARN:no_running_pod_found"
      jcmd_flags="WARN:no_running_pod_found"
      log "WARN" "ns=${ns} dc=${dc} :: No running pod found via labels deploymentconfig/deployment."
    fi

    apply_result="-"
    if [[ "$MODE" == "apply" ]]; then
      if echo "$dc_yaml" | grep -qE '^[[:space:]]*-[[:space:]]name:[[:space:]]JAVA_OPTIONS[[:space:]]*$'; then
        tmp_in="$(mktemp)"
        tmp_out="$(mktemp)"
        printf "%s" "$dc_yaml" > "$tmp_in"

        sed -E 's/^([[:space:]]*-[[:space:]]name:[[:space:]]*)JAVA_OPTIONS([[:space:]]*)$/\1JAVA_OPTS_APPEND\2/' \
          "$tmp_in" > "$tmp_out"

        if cmp -s "$tmp_in" "$tmp_out"; then
          apply_result="SKIP:no_effect"
          log "INFO" "ns=${ns} dc=${dc} :: apply mode but no effective change after transform."
        else
          # apply: keep stderr (so you see real errors)
          apply_out="$(run_cmd "$ns" "$dc" 0 -- oc apply -n "$ns" -f "$tmp_out" || true)"
          if echo "$apply_out" | grep -qiE '(configured|created|unchanged)'; then
            apply_result="$(echo "$apply_out" | head -n 1 | sanitize_one_line)"
          else
            apply_result="ERROR:oc_apply_failed"
          fi
        fi

        rm -f "$tmp_in" "$tmp_out"
      else
        apply_result="SKIP:no_JAVA_OPTIONS"
        log "INFO" "ns=${ns} dc=${dc} :: apply mode but JAVA_OPTIONS not present; no change."
      fi
    fi

    printf "%s\t%s\t%s\t%s\t%s\t%s\t%s\n" \
      "$ns" "$dc" "$java_keys" "$pod_name" "$java_ver" "$jcmd_flags" "$apply_result"

  done <<< "$dc_list"

done <<< "$NS_LIST_RAW"

log "INFO" "Completed mode=${MODE}"
log "INFO" "Log saved to ${LOG_FILE}"


⸻

Bu düzeltme senin log’daki semptomları nasıl bitiriyor?
	1.	DC listesi bozulmayacak
oc get dc ... -o jsonpath=... komutunda warnings stderr’e basıldığı için artık 2>/dev/null ile kesiyoruz → DC adı gerçekten “accounting-channel-v0” gibi gelecek.
	2.	.items[0] patlaması yok
Pod seçimi jsonpath’te range ile tüm pod isimlerini alıp head -n 1 yapıyor. Hiç pod yoksa boş döner → script “WARN:no_running_pod_found” yazar ve devam eder.

⸻

Küçük not: DC gerçekten deprecated (v4.14+)

Bu uyarı normal. Sizde DC hâlâ var ama OpenShift tarafı “deprecated” diye uyarıyor. Script artık bu warning’leri parse’a karıştırmayacak.

⸻

İstersen bir sonraki iyileştirme (isteğe bağlı ama faydalı): Pod label’ları her zaman deploymentconfig=<dc> olmayabiliyor. DC’nin selector’ını yaml’dan çekip (spec.selector) o selector ile pod bulma ekleyebilirim. Bu sayede label farklı olsa bile pod bulma oranı artar.